{"version":3,"file":"vega.schema.js","sourceRoot":"","sources":["../../src/vega.schema.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  AggregateOp,\n  BandScale,\n  BaseScale,\n  BinOrdinalScale,\n  ColorValueRef,\n  Compare as VgCompare,\n  ExprRef as VgExprRef,\n  GeoShapeTransform as VgGeoShapeTransform,\n  IdentityScale,\n  LayoutAlign,\n  LinearScale,\n  LogScale,\n  MarkConfig as VgMarkConfig,\n  NumericValueRef,\n  OrdinalScale,\n  PointScale,\n  PowScale,\n  ProjectionType,\n  QuantileScale,\n  QuantizeScale,\n  RangeBand,\n  RangeRaw,\n  RangeScheme,\n  ScaleData,\n  ScaleDataRef,\n  ScaledValueRef,\n  ScaleMultiDataRef,\n  ScaleMultiFieldsRef,\n  SequentialScale,\n  SignalRef,\n  SortField as VgSortField,\n  SqrtScale,\n  SymLogScale,\n  ThresholdScale,\n  TimeInterval,\n  TimeIntervalStep,\n  TimeScale,\n  Title as VgTitle,\n  Transforms as VgTransform,\n  UnionSortField as VgUnionSortField\n} from 'vega-typings';\nimport {isArray} from 'vega-util';\nimport {ValueOrGradientOrText} from './channeldef';\nimport {SortOrder} from './sort';\nimport {Flag, keys} from './util';\n\nexport {VgSortField, VgUnionSortField, VgCompare, VgTitle, LayoutAlign, ProjectionType, VgExprRef};\n\n// TODO: make recursive\ntype ExcludeMapped<T, E> = {\n  [P in keyof T]: Exclude<T[P], E>;\n};\n\n// Remove ValueRefs from mapped types\nexport type ExcludeMappedValueRef<T> = ExcludeMapped<T, ScaledValueRef<any> | NumericValueRef | ColorValueRef>;\n\nexport type ExcludeMappedValueRefButKeepSignal<T> = ExcludeMapped<\n  T,\n  Exclude<ScaledValueRef<any> | NumericValueRef | ColorValueRef, SignalRef>\n>;\n\nexport interface VgData {\n  name: string;\n  source?: string;\n  values?: any;\n  format?: {\n    type?: string;\n    parse?: string | object;\n    property?: string;\n    feature?: string;\n    mesh?: string;\n  };\n  url?: string;\n  transform?: VgTransform[];\n}\n\nexport type VgScaleDataRefWithSort = ScaleDataRef & {\n  sort?: VgSortField;\n};\n\nexport function isSignalRef(o: any): o is SignalRef {\n  return o && !!o['signal'];\n}\n\n// TODO: add type of value (Make it VgValueRef<V extends ValueOrGradient> {value?:V ...})\nexport interface VgValueRef {\n  value?: ValueOrGradientOrText | number[];\n  field?:\n    | string\n    | {\n        datum?: string;\n        group?: string;\n        parent?: string;\n      };\n  signal?: string;\n  scale?: string; // TODO: object\n  mult?: number;\n  offset?: number | VgValueRef;\n  band?: boolean | number | VgValueRef;\n  test?: string;\n}\n\n// TODO: add vg prefix\nexport type VgScaleMultiDataRefWithSort = ScaleMultiDataRef & {\n  fields: (any[] | VgScaleDataRefWithSort | SignalRef)[];\n  sort?: VgUnionSortField;\n};\n\nexport type VgMultiFieldsRefWithSort = ScaleMultiFieldsRef & {\n  sort?: VgUnionSortField;\n};\n\nexport type VgRange = RangeScheme | ScaleData | RangeBand | RangeRaw;\n\nexport function isVgRangeStep(range: VgRange): range is VgRangeStep {\n  return !!range['step'];\n}\n\nexport interface VgRangeStep {\n  step: number | SignalRef;\n}\n// Domains that are not a union of domains\nexport type VgNonUnionDomain = (null | string | number | boolean | SignalRef)[] | VgScaleDataRefWithSort | SignalRef;\n\nexport type VgDomain = BaseScale['domain'];\n\nexport type VgMarkGroup = any;\n\n/**\n * A combined type for any Vega scales that Vega-Lite can generate\n */\nexport type VgScale = Pick<BaseScale, 'type'> & {\n  range?: RangeScheme | RangeBand | ScaleData; // different Vega scales have conflicting range, need to union them here\n  nice?: boolean | number | TimeInterval | TimeIntervalStep | SignalRef; // different Vega scales have conflicting range, need to union them here\n  zero?: boolean | SignalRef; // LogScale only allow false, making the intersection type overly strict\n} & Omit<\n    // Continuous\n\n    LinearScale &\n      LogScale &\n      SymLogScale &\n      Partial<PowScale> & // use partial so exponent is not required\n      SqrtScale &\n      IdentityScale &\n      TimeScale &\n      // discretizing\n      QuantileScale &\n      QuantizeScale &\n      ThresholdScale &\n      BinOrdinalScale &\n      // sequential\n      SequentialScale &\n      // discrete\n      BandScale &\n      PointScale &\n      OrdinalScale,\n    'type' | 'range' | 'nice' | 'zero'\n  >;\n\nexport interface RowCol<T> {\n  row?: T;\n  column?: T;\n}\n\nexport interface VgLayout {\n  center?: boolean | RowCol<boolean>;\n  padding?: number | RowCol<number>;\n  headerBand?: number | RowCol<number>;\n  footerBand?: number | RowCol<number>;\n\n  titleAnchor?: 'start' | 'end' | RowCol<'start' | 'end'>;\n  offset?:\n    | number\n    | {\n        rowHeader?: number;\n        rowFooter?: number;\n        rowTitle?: number;\n        columnHeader?: number;\n        columnFooter?: number;\n        columnTitle?: number;\n      };\n  bounds?: 'full' | 'flush';\n  columns?: number | {signal: string};\n  align?: LayoutAlign | RowCol<LayoutAlign>;\n}\n\nexport function isDataRefUnionedDomain(domain: VgDomain): domain is VgScaleMultiDataRefWithSort {\n  if (!isArray(domain)) {\n    return 'fields' in domain && !('data' in domain);\n  }\n  return false;\n}\n\nexport function isFieldRefUnionDomain(domain: VgDomain): domain is VgMultiFieldsRefWithSort {\n  if (!isArray(domain)) {\n    return 'fields' in domain && 'data' in domain;\n  }\n  return false;\n}\n\nexport function isDataRefDomain(domain: VgDomain): domain is VgScaleDataRefWithSort {\n  if (!isArray(domain)) {\n    return 'field' in domain && 'data' in domain;\n  }\n  return false;\n}\n\nexport type VgEncodeChannel =\n  | 'x'\n  | 'x2'\n  | 'xc'\n  | 'width'\n  | 'y'\n  | 'y2'\n  | 'yc'\n  | 'height'\n  | 'opacity'\n  | 'fill'\n  | 'fillOpacity'\n  | 'stroke'\n  | 'strokeWidth'\n  | 'strokeCap'\n  | 'strokeOpacity'\n  | 'strokeDash'\n  | 'strokeDashOffset'\n  | 'strokeMiterLimit'\n  | 'strokeJoin'\n  | 'strokeOffset'\n  | 'strokeForeground'\n  | 'cursor'\n  | 'clip'\n  | 'size'\n  | 'shape'\n  | 'path'\n  | 'innerRadius'\n  | 'outerRadius'\n  | 'startAngle'\n  | 'endAngle'\n  | 'interpolate'\n  | 'tension'\n  | 'orient'\n  | 'url'\n  | 'align'\n  | 'baseline'\n  | 'text'\n  | 'dir'\n  | 'ellipsis'\n  | 'limit'\n  | 'dx'\n  | 'dy'\n  | 'radius'\n  | 'theta'\n  | 'angle'\n  | 'font'\n  | 'fontSize'\n  | 'fontWeight'\n  | 'fontStyle'\n  | 'tooltip'\n  | 'href'\n  | 'cursor'\n  | 'defined'\n  | 'cornerRadius'\n  | 'cornerRadiusTopLeft'\n  | 'cornerRadiusTopRight'\n  | 'cornerRadiusBottomRight'\n  | 'cornerRadiusBottomLeft'\n  | 'scaleX'\n  | 'scaleY';\n\nexport type VgEncodeEntry = {[k in VgEncodeChannel]?: VgValueRef | (VgValueRef & {test?: string})[]};\n\n// TODO: make export interface VgEncodeEntry {\n//   x?: VgValueRef<number>\n//   y?: VgValueRef<number>\n//  ...\n//   color?: VgValueRef<string>\n//  ...\n// }\n\nexport type VgPostEncodingTransform = VgGeoShapeTransform;\n\nexport type VgGuideEncode = any; // TODO: replace this (See guideEncode in Vega Schema)\n\nexport type StrokeCap = 'butt' | 'round' | 'square';\nexport type StrokeJoin = 'miter' | 'round' | 'bevel';\nexport type Dir = 'ltr' | 'rtl';\n\nconst VG_MARK_CONFIG_INDEX: Flag<keyof VgMarkConfig> = {\n  opacity: 1,\n  fill: 1,\n  fillOpacity: 1,\n  stroke: 1,\n  strokeCap: 1,\n  strokeWidth: 1,\n  strokeOpacity: 1,\n  strokeDash: 1,\n  strokeDashOffset: 1,\n  strokeJoin: 1,\n  strokeOffset: 1,\n  strokeMiterLimit: 1,\n  size: 1,\n  shape: 1,\n  interpolate: 1,\n  tension: 1,\n  orient: 1,\n  align: 1,\n  baseline: 1,\n  text: 1,\n  dir: 1,\n  dx: 1,\n  dy: 1,\n  ellipsis: 1,\n  limit: 1,\n  radius: 1,\n  theta: 1,\n  angle: 1,\n  font: 1,\n  fontSize: 1,\n  fontWeight: 1,\n  fontStyle: 1,\n  lineBreak: 1,\n  lineHeight: 1,\n  cursor: 1,\n  href: 1,\n  tooltip: 1,\n  cornerRadius: 1,\n  cornerRadiusTopLeft: 1,\n  cornerRadiusTopRight: 1,\n  cornerRadiusBottomLeft: 1,\n  cornerRadiusBottomRight: 1,\n  aspect: 1,\n  width: 1,\n  height: 1\n\n  // commented below are vg channel that do not have mark config.\n  // x: 1,\n  // y: 1,\n  // x2: 1,\n  // y2: 1,\n\n  // xc'|'yc'\n  // clip: 1,\n  // endAngle: 1,\n  // innerRadius: 1,\n  // outerRadius: 1,\n  // path: 1,\n  // startAngle: 1,\n  // url: 1,\n};\n\nexport const VG_MARK_CONFIGS = keys(VG_MARK_CONFIG_INDEX);\n\n// Vega's cornerRadius channels.\nexport const VG_CORNERRADIUS_CHANNELS = [\n  'cornerRadius',\n  'cornerRadiusTopLeft',\n  'cornerRadiusTopRight',\n  'cornerRadiusBottomLeft',\n  'cornerRadiusBottomRight'\n] as const;\n\nexport interface VgComparator {\n  field?: string | string[];\n  order?: SortOrder | SortOrder[];\n}\n\nexport interface VgJoinAggregateTransform {\n  type: 'joinaggregate';\n  as?: string[];\n  ops?: AggregateOp[];\n  fields?: string[];\n  groupby?: string[];\n}\n"]}