{"version":3,"file":"assemble.js","sourceRoot":"","sources":["../../../../src/compile/legend/assemble.ts"],"names":[],"mappings":"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","sourcesContent":["import {Legend as VgLegend, LegendEncode} from 'vega-typings';\nimport {SIGNAL_LEGEND_PROP_INDEX} from '../../legend';\nimport {keys, replaceAll, stringify, vals} from '../../util';\nimport {isSignalRef, VgEncodeChannel, VgValueRef} from '../../vega.schema';\nimport {Model} from '../model';\nimport {LegendComponent} from './component';\nimport {mergeLegendComponent} from './parse';\n\nfunction setLegendEncode(\n  legend: VgLegend,\n  part: keyof LegendEncode,\n  vgProp: VgEncodeChannel,\n  vgRef: VgValueRef | VgValueRef[]\n) {\n  legend.encode = legend.encode ?? {};\n  legend.encode[part] = legend.encode[part] ?? {};\n  legend.encode[part].update = legend.encode[part].update ?? {};\n  // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n  (legend.encode[part].update[vgProp] as any) = vgRef;\n}\n\nexport function assembleLegends(model: Model): VgLegend[] {\n  const legendComponentIndex = model.component.legends;\n  const legendByDomain: {[domainHash: string]: LegendComponent[]} = {};\n\n  for (const channel of keys(legendComponentIndex)) {\n    const scaleComponent = model.getScaleComponent(channel);\n    const domainHash = stringify(scaleComponent.get('domains'));\n    if (legendByDomain[domainHash]) {\n      for (const mergedLegendComponent of legendByDomain[domainHash]) {\n        const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);\n        if (!merged) {\n          // If cannot merge, need to add this legend separately\n          legendByDomain[domainHash].push(legendComponentIndex[channel]);\n        }\n      }\n    } else {\n      legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];\n    }\n  }\n\n  return vals(legendByDomain)\n    .flat()\n    .map(assembleLegend);\n}\n\nexport function assembleLegend(legendCmpt: LegendComponent) {\n  const {labelExpr, selections, ...legend} = legendCmpt.combine();\n\n  if (legend.encode?.symbols) {\n    const out = legend.encode.symbols.update;\n    if (out.fill && out.fill['value'] !== 'transparent' && !out.stroke && !legend.stroke) {\n      // For non color channel's legend, we need to override symbol stroke config from Vega config if stroke channel is not used.\n      out.stroke = {value: 'transparent'};\n    }\n\n    if (legend.fill) {\n      // If top-level fill is defined, for non color channel's legend, we need to remove fill.\n      delete out.fill;\n    }\n  }\n\n  if (labelExpr !== undefined) {\n    let expr = labelExpr;\n    if (legend.encode?.labels?.update?.text && isSignalRef(legend.encode.labels.update.text)) {\n      expr = replaceAll(labelExpr, 'datum.label', legend.encode.labels.update.text.signal);\n    }\n\n    setLegendEncode(legend, 'labels', 'text', {signal: expr});\n  }\n\n  for (const prop in legend) {\n    const propValue = legend[prop];\n    if (isSignalRef(propValue)) {\n      const propIndex = SIGNAL_LEGEND_PROP_INDEX[prop];\n      if (propIndex) {\n        const {vgProp, part} = propIndex;\n        setLegendEncode(legend, part, vgProp, propValue);\n        delete legend[prop];\n      }\n    }\n  }\n\n  return legend;\n}\n"]}