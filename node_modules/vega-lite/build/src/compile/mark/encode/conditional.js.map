{"version":3,"file":"conditional.js","sourceRoot":"","sources":["../../../../../src/compile/mark/encode/conditional.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,KAAK,EAAC,MAAM,WAAW,CAAC;AAChC,OAAO,EAML,sBAAsB,EAGvB,MAAM,qBAAqB,CAAC;AAE7B,OAAO,EAAC,UAAU,EAAC,MAAM,iBAAiB,CAAC;AAC3C,OAAO,EAAC,uBAAuB,EAAC,MAAM,uBAAuB,CAAC;AAG9D;;;GAGG;AACH,MAAM,UAAU,aAAa,CAC3B,KAAgB,EAChB,UAA6B,EAC7B,SAAiB,EACjB,KAA8E;IAE9E,MAAM,SAAS,GAAG,UAAU,IAAI,UAAU,CAAC,SAAS,CAAC;IACrD,MAAM,QAAQ,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC;IACnC,IAAI,SAAS,EAAE;QACb,MAAM,UAAU,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC;QACpC,MAAM,YAAY,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;YACtC,MAAM,iBAAiB,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACnC,MAAM,IAAI,GAAG,sBAAsB,CAAM,CAAC,CAAC;gBACzC,CAAC,CAAC,uBAAuB,CAAC,KAAK,EAAG,CAA+B,CAAC,SAAS,CAAC,CAAC,2DAA2D;gBACxI,CAAC,CAAC,UAAU,CAAC,KAAK,EAAG,CAA+B,CAAC,IAAI,CAAC,CAAC,CAAC,2DAA2D;YACzH,uBACE,IAAI,IACD,iBAAiB,EACpB;QACJ,CAAC,CAAC,CAAC;QACH,OAAO;YACL,CAAC,SAAS,CAAC,EAAE,CAAC,GAAG,YAAY,EAAE,GAAG,CAAC,QAAQ,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;SAC9E,CAAC;KACH;SAAM;QACL,OAAO,QAAQ,KAAK,SAAS,CAAC,CAAC,CAAC,EAAC,CAAC,SAAS,CAAC,EAAE,QAAQ,EAAC,CAAC,CAAC,CAAC,EAAE,CAAC;KAC9D;AACH,CAAC","sourcesContent":["import {array} from 'vega-util';\nimport {\n  ChannelDef,\n  Conditional,\n  ConditionalPredicate,\n  ConditionalSelection,\n  FieldDef,\n  isConditionalSelection,\n  ValueDef,\n  ValueOrGradientOrText\n} from '../../../channeldef';\nimport {VgEncodeEntry, VgValueRef} from '../../../vega.schema';\nimport {expression} from '../../predicate';\nimport {parseSelectionPredicate} from '../../selection/parse';\nimport {UnitModel} from '../../unit';\n\n/**\n * Return a mixin that includes a Vega production rule for a Vega-Lite conditional channel definition.\n * or a simple mixin if channel def has no condition.\n */\nexport function wrapCondition<FD extends FieldDef<any>, V extends ValueOrGradientOrText>(\n  model: UnitModel,\n  channelDef: ChannelDef<FD, V>,\n  vgChannel: string,\n  refFn: (cDef: ChannelDef<FD, V> | Conditional<ValueDef<V> | FD>) => VgValueRef\n): VgEncodeEntry {\n  const condition = channelDef && channelDef.condition;\n  const valueRef = refFn(channelDef);\n  if (condition) {\n    const conditions = array(condition);\n    const vgConditions = conditions.map(c => {\n      const conditionValueRef = refFn(c);\n      const test = isConditionalSelection<any>(c)\n        ? parseSelectionPredicate(model, (c as ConditionalSelection<any>).selection) // FIXME: remove casting once TS is no longer dumb about it\n        : expression(model, (c as ConditionalPredicate<any>).test); // FIXME: remove casting once TS is no longer dumb about it\n      return {\n        test,\n        ...conditionValueRef\n      };\n    });\n    return {\n      [vgChannel]: [...vgConditions, ...(valueRef !== undefined ? [valueRef] : [])]\n    };\n  } else {\n    return valueRef !== undefined ? {[vgChannel]: valueRef} : {};\n  }\n}\n"]}