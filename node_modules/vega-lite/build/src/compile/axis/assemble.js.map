{"version":3,"file":"assemble.js","sourceRoot":"","sources":["../../../../src/compile/axis/assemble.ts"],"names":[],"mappings":"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","sourcesContent":["import {Axis as VgAxis, AxisEncode, NewSignal, SignalRef, Text} from 'vega-typings';\nimport {array, stringValue} from 'vega-util';\nimport {AXIS_PARTS, AXIS_PROPERTY_TYPE, CONDITIONAL_AXIS_PROP_INDEX, isConditionalAxisValue} from '../../axis';\nimport {POSITION_SCALE_CHANNELS} from '../../channel';\nimport {defaultTitle, FieldDefBase} from '../../channeldef';\nimport {Config} from '../../config';\nimport {isText} from '../../title';\nimport {getFirstDefined, keys, replaceAll} from '../../util';\nimport {isSignalRef, VgEncodeChannel, VgValueRef} from '../../vega.schema';\nimport {Model} from '../model';\nimport {expression} from '../predicate';\nimport {AxisComponent, AxisComponentIndex} from './component';\n\nfunction assembleTitle(title: Text | FieldDefBase<string>[], config: Config): Text {\n  if (!title) {\n    return undefined;\n  }\n  if (!isText(title)) {\n    return title.map(fieldDef => defaultTitle(fieldDef, config)).join(', ');\n  }\n  return title;\n}\n\nfunction setAxisEncode(\n  axis: Omit<VgAxis, 'orient' | 'scale'>,\n  part: keyof AxisEncode,\n  vgProp: VgEncodeChannel,\n  vgRef: VgValueRef | readonly VgValueRef[]\n) {\n  axis.encode = axis.encode ?? {};\n  axis.encode[part] = axis.encode[part] ?? {};\n  axis.encode[part].update = axis.encode[part].update ?? {};\n  // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n  (axis.encode[part].update[vgProp] as any) = vgRef;\n}\n\nexport function assembleAxis(\n  axisCmpt: AxisComponent,\n  kind: 'main' | 'grid',\n  config: Config,\n  opt: {\n    header: boolean; // whether this is called via a header\n  } = {header: false}\n): VgAxis {\n  const {orient, scale, labelExpr, labelOffset, title, zindex, ...axis} = axisCmpt.combine();\n\n  for (const prop in axis) {\n    const propType = AXIS_PROPERTY_TYPE[prop];\n    const propValue = axis[prop];\n\n    if (propType && propType !== kind && propType !== 'both') {\n      // Remove properties that are not valid for this kind of axis\n      delete axis[prop];\n    } else if (isConditionalAxisValue(propValue)) {\n      // deal with conditional axis value\n\n      const {condition, value} = propValue;\n      const conditions = array(condition);\n\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n      if (propIndex) {\n        const {vgProp, part} = propIndex;\n        // If there is a corresponding Vega property for the channel,\n        // use Vega's custom axis encoding and delete the original axis property to avoid conflicts\n\n        const vgRef = [\n          ...conditions.map(c => {\n            const {value: v, test} = c;\n            return {\n              test: expression(null, test),\n              value: v\n            };\n          }),\n          {value}\n        ];\n        setAxisEncode(axis, part, vgProp, vgRef);\n        delete axis[prop];\n      } else if (propIndex === null) {\n        // If propIndex is null, this means we support conditional axis property by converting the condition to signal insteed.\n        const signalRef: SignalRef = {\n          signal:\n            conditions\n              .map(c => {\n                const {value: v, test} = c;\n                return `${expression(null, test)} ? ${stringValue(v)} : `;\n              })\n              .join('') + stringValue(value)\n        };\n        axis[prop] = signalRef;\n      }\n    } else if (isSignalRef(propValue)) {\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n      if (propIndex) {\n        const {vgProp, part} = propIndex;\n        setAxisEncode(axis, part, vgProp, propValue);\n        delete axis[prop];\n      } // else do nothing since the property already supports signal\n    }\n  }\n\n  if (kind === 'grid') {\n    if (!axis.grid) {\n      return undefined;\n    }\n\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      // Only need to keep encode block for grid\n      const {grid} = axis.encode;\n      axis.encode = {\n        ...(grid ? {grid} : {})\n      };\n\n      if (keys(axis.encode).length === 0) {\n        delete axis.encode;\n      }\n    }\n\n    return {\n      scale,\n      orient,\n      ...axis,\n      domain: false,\n      labels: false,\n\n      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n      // would not affect gridAxis\n      maxExtent: 0,\n      minExtent: 0,\n      ticks: false,\n      zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n    };\n  } else {\n    // kind === 'main'\n\n    if (!opt.header && axisCmpt.mainExtracted) {\n      // if mainExtracted has been extracted to a separate facet\n      return undefined;\n    }\n\n    if (labelExpr !== undefined) {\n      let expr = labelExpr;\n      if (axis.encode?.labels?.update && isSignalRef(axis.encode.labels.update.text)) {\n        expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n      }\n\n      setAxisEncode(axis, 'labels', 'text', {signal: expr});\n    }\n\n    if (labelOffset) {\n      setAxisEncode(axis, 'labels', orient === 'bottom' || orient === 'top' ? 'dx' : 'dy', {value: labelOffset});\n    }\n\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      for (const part of AXIS_PARTS) {\n        if (!axisCmpt.hasAxisPart(part)) {\n          delete axis.encode[part];\n        }\n      }\n      if (keys(axis.encode).length === 0) {\n        delete axis.encode;\n      }\n    }\n\n    const titleString = assembleTitle(title, config);\n\n    return {\n      scale,\n      orient,\n      grid: false,\n      ...(titleString ? {title: titleString} : {}),\n      ...axis,\n      zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n    };\n  }\n}\n\n/**\n * Add axis signals so grid line works correctly\n * (Fix https://github.com/vega/vega-lite/issues/4226)\n */\nexport function assembleAxisSignals(model: Model): NewSignal[] {\n  const {axes} = model.component;\n  for (const channel of POSITION_SCALE_CHANNELS) {\n    if (axes[channel]) {\n      for (const axis of axes[channel]) {\n        if (!axis.get('gridScale')) {\n          // If there is x-axis but no y-scale for gridScale, need to set height/weight so x-axis can draw the grid with the right height. Same for y-axis and width.\n\n          const sizeType = channel === 'x' ? 'height' : 'width';\n          return [\n            {\n              name: sizeType,\n              update: model.getSizeSignalRef(sizeType).signal\n            }\n          ];\n        }\n      }\n    }\n  }\n  return [];\n}\n\nexport function assembleAxes(axisComponents: AxisComponentIndex, config: Config): VgAxis[] {\n  const {x = [], y = []} = axisComponents;\n  return [\n    ...x.map(a => assembleAxis(a, 'grid', config)),\n    ...y.map(a => assembleAxis(a, 'grid', config)),\n    ...x.map(a => assembleAxis(a, 'main', config)),\n    ...y.map(a => assembleAxis(a, 'main', config))\n  ].filter(a => a); // filter undefined\n}\n"]}