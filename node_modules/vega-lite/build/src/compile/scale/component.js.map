{"version":3,"file":"component.js","sourceRoot":"","sources":["../../../../src/compile/scale/component.ts"],"names":[],"mappings":"AACA,OAAO,EAAC,OAAO,EAAC,MAAM,WAAW,CAAC;AAIlC,OAAO,EAAC,IAAI,EAAC,MAAM,YAAY,CAAC;AAEhC,OAAO,EAAW,KAAK,EAAC,MAAM,UAAU,CAAC;AAczC,MAAM,OAAO,cAAe,SAAQ,KAA0B;IAG5D,YAAY,IAAY,EAAE,gBAAqC;QAC7D,KAAK,CACH,EAAE,EAAE,+BAA+B;QACnC,EAAC,IAAI,EAAC,CAAC,oCAAoC;SAC5C,CAAC;QANG,WAAM,GAAG,KAAK,CAAC;QAOpB,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,gBAAgB,CAAC,CAAC;IACjD,CAAC;IAED;;OAEG;IACI,4BAA4B;QACjC,IAAI,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,KAAK,EAAE;YAC9B,OAAO,IAAI,CAAC;SACb;QACD,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;IAChG,CAAC;CACF","sourcesContent":["import {SignalRef} from 'vega-typings/types';\nimport {isArray} from 'vega-util';\nimport {ScaleChannel} from '../../channel';\nimport {Scale, ScaleType} from '../../scale';\nimport {SelectionExtent} from '../../selection';\nimport {some} from '../../util';\nimport {VgNonUnionDomain, VgScale} from '../../vega.schema';\nimport {Explicit, Split} from '../split';\n\n/**\n * All VgDomain property except domain.\n * (We exclude domain as we have a special \"domains\" array that allow us merge them all at once in assemble.)\n */\nexport type ScaleComponentProps = Omit<VgScale, 'domain' | 'domainRaw' | 'reverse'> & {\n  domains: VgNonUnionDomain[];\n  selectionExtent?: SelectionExtent;\n  reverse?: boolean | SignalRef; // Need override since Vega doesn't official support scale reverse yet (though it does in practice)\n};\n\nexport type Range = ScaleComponentProps['range'];\n\nexport class ScaleComponent extends Split<ScaleComponentProps> {\n  public merged = false;\n\n  constructor(name: string, typeWithExplicit: Explicit<ScaleType>) {\n    super(\n      {}, // no initial explicit property\n      {name} // name as initial implicit property\n    );\n    this.setWithExplicit('type', typeWithExplicit);\n  }\n\n  /**\n   * Whether the scale definitely includes zero in the domain\n   */\n  public domainDefinitelyIncludesZero() {\n    if (this.get('zero') !== false) {\n      return true;\n    }\n    return some(this.get('domains'), d => isArray(d) && d.length === 2 && d[0] <= 0 && d[1] >= 0);\n  }\n}\n\nexport type ScaleComponentIndex = Partial<Record<ScaleChannel, ScaleComponent>>;\n\nexport type ScaleIndex = Partial<Record<ScaleChannel, Scale>>;\n"]}